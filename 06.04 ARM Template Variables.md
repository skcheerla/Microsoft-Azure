ARM Template **Variables** are used to simplify your template by defining values that are used repeatedly or are constructed from complex expressions. They help make your templates more readable, reusable, and maintainable.

Variables are defined in the dedicated **`variables`** section of the ARM JSON file.

-----

## Structure and Definition of Variables

Variables are defined as key-value pairs, where the key is the variable name, and the value is either a **static value** or a **template expression** (using functions, parameters, or other variables).

### Example Variables Section

```json
"variables": {
  // Static string value
  "location": "[resourceGroup().location]",
  
  // Value constructed using functions and parameters
  "storageAccountName": "[toLower(concat('sa', parameters('environmentPrefix'), uniqueString(resourceGroup().id)))]",
  
  // Object variable for repeated configurations (e.g., Virtual Machine sizes)
  "vmSizes": {
    "small": "Standard_A1_v2",
    "medium": "Standard_B2s",
    "large": "Standard_D2s_v3"
  },
  
  // Array variable for allowed values
  "vnetAddressPrefixes": [
    "10.0.0.0/16",
    "192.168.0.0/16"
  ]
}
```

### Key Characteristics

1.  **Readability:** They allow you to define complex logic (like generating a unique name) once and reference it simply by name throughout the template.
2.  **Reusability:** A single variable can be used across multiple resource definitions (e.g., using a variable for the **Resource Location** for all resources).
3.  **Compile-Time Resolution:** Variables are resolved **before** the deployment begins (during the template parsing phase). This means they **cannot** use run-time functions like `reference()` or `list*()`, which require the resource to already be deployed.

-----

## How Variables are Used

Variables are referenced throughout the `resources`, and `outputs` sections using the `variables()` function within square brackets `[]`.

### 1\. Simple Usage (String/Integer)

Using a variable to set the name and location of a Storage Account:

```json
"resources": [
  {
    "type": "Microsoft.Storage/storageAccounts",
    "apiVersion": "2023-01-01",
    // Resource name uses a concatenated variable
    "name": "[variables('storageAccountName')]", 
    // Location uses a variable derived from the resource group location
    "location": "[variables('location')]", 
    // ... other properties
  }
]
```

### 2\. Accessing Properties in Object Variables

If you have a variable defined as an object (like `vmSizes` in the example above), you access its properties using dot notation:

```json
"resources": [
  {
    "type": "Microsoft.Compute/virtualMachines",
    "apiVersion": "2023-03-01",
    // Sku size is selected from the object variable
    "properties": {
      "hardwareProfile": {
        "vmSize": "[variables('vmSizes').medium]" 
      },
      // ...
    }
  }
]
```

### 3\. Creating Configuration Objects

A common pattern is to create a variable that holds configuration settings for multiple resources, reducing repetition in the `resources` section:

```json
"variables": {
  "subnetConfiguration": {
    "addressPrefix": "10.0.0.0/24",
    "name": "defaultSubnet"
  }
},
"resources": [
  {
    "type": "Microsoft.Network/virtualNetworks",
    "apiVersion": "2023-04-01",
    "properties": {
      "addressSpace": {
        "addressPrefixes": ["10.0.0.0/16"]
      },
      "subnets": [
        {
          // Reference the entire configuration object
          "properties": "[variables('subnetConfiguration')]" 
        }
      ]
    }
  }
]
```
