Azure Container Registry (**ACR**) is a managed, private Docker registry service in Azure for building, storing, and managing container images and related artifacts.

Here's an overview of the requested topics:

## Creating and Maintaining Azure Container Registries

### Creation

You can create an ACR instance using the **Azure Portal**, **Azure CLI** (using `az acr create`), or **Azure PowerShell**.

1.  **Select a service tier (SKU):**

      * **Basic:** Cost-effective, good for learning and small workloads.
      * **Standard:** Offers more throughput and storage, suitable for production.
      * **Premium:** Provides the highest capacity, throughput, and features like **Geo-replication** (for global distribution) and **Virtual Network service endpoints/Private Link** (for network security).

2.  **Configuration:** You define a globally unique **Registry name** and choose an Azure **Resource Group** and **Location**.

### Maintenance and Key Features

  * **Security:** Integrate with **Microsoft Entra ID (formerly Azure Active Directory)** for authentication and **Role-Based Access Control (RBAC)**. You can also use **Managed Identities** for Azure services.
  * **Geo-replication:** (Premium tier) Allows you to manage a single registry across multiple global regions, improving deployment speed for globally distributed applications.
  * **Networking:** Secure your registry using **Private Link** to make it accessible only from a private network.
  * **Content Management:** View and manage repositories, tags, and container images via the Azure Portal or Azure CLI. You can also **lock** images to prevent accidental deletion.
  * **Webhooks:** Configure webhooks to automatically trigger actions when certain events occur, like an image being pushed to the registry.

-----

## Azure Container Registry Tasks (ACR Tasks)

ACR Tasks is a suite of features for streamlined and efficient **cloud-based container image building, patching, and maintenance**. It eliminates the need for a local Docker Engine installation.

### Key Capabilities

  * **Quick Task (`az acr build`):** Offloads a single `docker build` and `docker push` operation to Azure on-demand, accelerating your inner development loop.
  * **Automated Builds:** Trigger image builds based on:
      * **Source Code Commit:** When code is committed to a Git repository (GitHub or Azure DevOps).
      * **Base Image Updates:** Automatically rebuilds application images when the **base image** (e.g., an OS patch) it's built upon is updated in ACR or Docker Hub.
      * **Timers:** Schedule tasks to run at defined intervals.
  * **Multi-Step Tasks:** Define complex, multi-step workflows in a YAML file for building, testing, and patching multiple containers in sequence or parallel.

-----

## Azure Services with Direct ACR Support

Many Azure services are natively integrated with ACR for deploying containerized applications:

  * **Azure Kubernetes Service (AKS):** Seamlessly pulls images from ACR to deploy on a managed Kubernetes cluster.
  * **Azure App Service / Azure Container Apps:** Easily deploys single-container or microservice-based applications directly from ACR.
  * **Azure Functions:** Can run containerized functions pulling images from ACR.
  * **Azure Container Instances (ACI):** For running single containers without managing a full orchestrator.
  * **Azure Machine Learning:** Used to store and manage Docker images for training and deploying models.

-----

## Pushing Images to ACR using Azure Pipelines/Jenkins

Both Azure Pipelines and Jenkins offer dedicated mechanisms for integrating with ACR to automate your CI/CD process.

### Using Azure Pipelines

Azure Pipelines, part of Azure DevOps, uses the **`Docker@2`** task to handle building and pushing images.

1.  **Create an Azure Resource Manager Service Connection:**

      * In Azure DevOps, create a **Service Connection** of type **Docker Registry** or **Azure Resource Manager**. This grants the pipeline the necessary permissions (using a **Service Principal**) to authenticate with your ACR.

2.  **Define the Pipeline (YAML Example):**
    The `Docker@2` task's `buildAndPush` command combines the Docker build and push operations in a single step.

    ```yaml
    steps:
    - task: Docker@2
      displayName: Build and Push Image
      inputs:
        containerRegistry: '<Name of your Docker Registry Service Connection>' # The service connection created in step 1
        repository: 'myapp-repo'
        command: 'buildAndPush'
        Dockerfile: '**/Dockerfile'
        tags: |
          $(Build.BuildId)
          latest
    ```

### Using Jenkins

Jenkins can use the standard Docker CLI commands within a pipeline script, often using credentials stored in Jenkins, or leverage a specific Azure plugin.

1.  **Set up Credentials:**

      * Create an **Azure Service Principal** with permissions to push to your ACR.
      * Store the Service Principal's **App ID (Username)** and **Password** in Jenkins as **Username with password credentials**.

2.  **Define the Pipeline (Scripted or Declarative):**
    You use the standard `docker login`, `docker build`, and `docker push` commands within an `sh` (shell) step.

    ```groovy
    pipeline {
        agent any
        tools {
            docker 'docker' // Ensure Docker tool is configured in Jenkins
        }
        stages {
            stage('Build and Push') {
                steps {
                    script {
                        def acrLoginServer = 'myregistry.azurecr.io'
                        // Bind the Azure credentials to environment variables
                        withCredentials([usernamePassword(credentialsId: 'acr-sp-credentials', passwordVariable: 'ACR_PASSWORD', usernameVariable: 'ACR_USERNAME')]) {
                            // 1. Login to ACR
                            sh "docker login ${acrLoginServer} -u ${env.ACR_USERNAME} -p ${env.ACR_PASSWORD}"
                            // 2. Build and Tag the image
                            def imageName = "${acrLoginServer}/myapp-repo:${env.BUILD_ID}"
                            sh "docker build -t ${imageName} ."
                            // 3. Push the image
                            sh "docker push ${imageName}"
                        }
                    }
                }
            }
        }
    }
    ```
