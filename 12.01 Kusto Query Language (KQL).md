**Kusto Query Language (KQL)** is a powerful, read-only language developed by Microsoft for querying structured, semi-structured, and unstructured data. In Azure, it is most commonly used in **Azure Monitor Logs** (Log Analytics), **Azure Data Explorer**, and **Microsoft Sentinel** for analyzing logs, metrics, and telemetry data.

KQL is designed to be easy to read and write, using a data-flow model where data is passed from one command (operator) to the next using the **pipe character** (`|`). The query generally starts with a table name and then applies filters, aggregations, and projections sequentially.

-----

## Key KQL Operators

| Operator | Purpose | SQL Equivalent |
| :--- | :--- | :--- |
| `tablename` | The starting point of the query, specifying the data source. | `FROM tablename` |
| `where` | Filters the table's rows based on a specific condition. | `WHERE` |
| `project` | Selects specific columns to include in the output. | `SELECT` |
| `summarize` | Groups data and calculates aggregations (e.g., count, sum, average). | `GROUP BY` and aggregate functions |
| `extend` | Creates a new calculated column. | N/A (similar to a calculated column in `SELECT`) |
| `order by` | Sorts the result set by one or more columns. | `ORDER BY` |
| `take` | Limits the number of rows returned. | `TOP` or `LIMIT` |

-----

## KQL Queries for Common Scenarios

Here are a few example queries using KQL to understand common Azure monitoring scenarios. These are typically run in the **Log Analytics** workspace in Azure Monitor.

### 1\. Simple Data Retrieval and Filtering

**Scenario:** Get the last 10 records from the `SecurityEvent` table that represent a successful login (EventID 4624) in the last hour.

```kql
SecurityEvent
| where TimeGenerated > ago(1h)
| where EventID == 4624
| take 10
| project TimeGenerated, Computer, Account
```

  * `SecurityEvent`: Specifies the table to query.
  * `where TimeGenerated > ago(1h)`: Filters records to only those created in the last 1 hour.
  * `where EventID == 4624`: Filters to a specific Windows Event ID for successful logons.
  * `take 10`: Limits the output to 10 records.
  * `project ...`: Selects and displays only the `TimeGenerated`, `Computer`, and `Account` columns.

### 2\. Aggregation and Time-Series Analysis

**Scenario:** Count the total number of errors (`Level == 2`) per computer over the last 7 days, grouped by day.

```kql
Heartbeat
| where TimeGenerated > ago(7d)
| summarize DailyErrorCount = countif(Computer == "Error") by bin(TimeGenerated, 1d)
| render timechart 
```

  * `Heartbeat`: Specifies the table (often used for agent status).
  * `summarize ... by bin(TimeGenerated, 1d)`: Groups the records by a 1-day interval (`bin`) and calculates a count of records where the `Computer` column equals "Error" (using `countif`).
  * `render timechart`: Displays the results as a line chart over time. (Note: The `Heartbeat` table doesn't have an error level, but this demonstrates the syntax for summarizing by time).

### 3\. Calculating Percentiles and Sorting

**Scenario:** Find the 95th percentile and average duration of application requests in the last 24 hours, grouped by the request name.

```kql
AppRequests
| where TimeGenerated > ago(24h)
| summarize 
    AvgDuration = avg(DurationMs), 
    P95Duration = percentile(DurationMs, 95), 
    TotalRequests = count()
  by OperationName
| order by P95Duration desc
```

  * `AppRequests`: Specifies the table for application request data.
  * `summarize ... by OperationName`: Groups the results by the request name and calculates the average duration, the 95th percentile duration, and the total count of requests.
  * `order by P95Duration desc`: Sorts the final result table to show the slowest requests first.

This video provides an excellent introduction to the basics and fundamental building blocks of the KQL language, which is essential for working with log data in Azure. [Kusto Query Language Tutorial | Basics | Beginner To Pro in 30 Minutes](https://www.google.com/search?q=https://www.youtube.com/watch%3Fv%3DImqRQJfnSH4)


<img width="942" height="527" alt="image" src="https://github.com/user-attachments/assets/8479a7ea-769d-4f57-98a3-70ced304bc66" />


The **Kusto Query Language (KQL)** supports several **scalar data types**, which are single values that hold specific kinds of data. These are the fundamental types used for columns in KQL tables, variables defined with `let` statements, and values returned by functions.

The core scalar data types in KQL are:

| Type Name | Alternative Name(s) | Description | Example Literal |
| :--- | :--- | :--- | :--- |
| **`string`** | | A sequence of zero or more Unicode characters (text). | `"Hello, KQL"` |
| **`long`** | `int` | A signed 64-bit integer (whole number). `int` is also supported but resolves to a 32-bit signed integer. | `123456` |
| **`real`** | `double` | A 64-bit double-precision floating-point number (decimal numbers). | `1.23` or `1.0` |
| **`decimal`** | | A 128-bit wide decimal number, used for high-precision calculations like currency. | `decimal(10.99)` |
| **`bool`** | `boolean` | A logical value that is either **`true`** (`1`) or **`false`** (`0`). | `true` or `false` |
| **`datetime`** | `date` | An instant in time, typically expressed as a date and time of day (up to the millisecond). | `datetime(2025-10-04 10:00:00)` |
| **`timespan`** | `time` | A time interval, representing a duration of time (e.g., 5 days, 1 hour). | `5d` or `1h` or `timespan(0.01:00:00)` |
| **`guid`** | `uuid`, `uniqueid` | A 128-bit globally unique value (UUID). | `guid("12345678-abcd-1234-abcd-1234567890ab")` |
| **`dynamic`** | | A container that can hold any of the other scalar data types, or a structured value like an **array** or a **property bag** (dictionary/JSON object). | `dynamic({"key": "value", "count": 10})` |

***

### Important Type Considerations

* **Case Sensitivity:** KQL is generally case-sensitive for everything, including table and column names, so ensure you use the correct casing for values, especially with strings.
* **Null Values:** All non-`string` data types include a special **`null`** value, representing the lack of data or a data mismatch. The `isnull()` function is used to check for this value.
* **`dynamic` Type:** This is particularly important when dealing with unstructured data like JSON logs in Azure Monitor. It allows you to ingest and query semi-structured data, and KQL provides specific operators (like `parse_json()`, `mv-expand`, and dynamic object accessors) to manipulate it.
* 


**Kusto Control Commands** (also known as **Management Commands**) are requests to the Kusto service to **process or modify data or metadata**. Unlike Kusto Query Language (KQL) queries, which are read-only requests to process data and return results, control commands are used for administration, data ingestion, scheme modifications, and policy management.

### Key Differentiator

The fundamental distinction between a KQL query and a Control Command is its syntax:

  * **Control Commands** **must** start with the **dot (`.`)** character (e.g., `.show tables`).
  * **KQL Queries** **must not** start with the dot (`.`) character (e.g., `StormEvents | count`).

This design is a security measure to prevent embedding commands (which modify state) within read-only queries.

-----

### Common Categories of Control Commands

Control commands cover a wide range of administrative and data management tasks. They can be broadly categorized as:

#### 1\. Schema and Metadata Management

These commands are used to create, alter, or drop databases, tables, columns, and functions.

| Command | Purpose | Example |
| :--- | :--- | :--- |
| **`.create table`** | Creates a new table with a specified schema. | `.create table Logs (Timestamp: datetime, Message: string)` |
| **`.alter table`** | Modifies an existing table's schema (e.g., adding a column). | `.alter table Logs (Level: string)` |
| **`.drop table`** | Deletes a table. | `.drop table Logs` |
| **`.create function`** | Creates a stored KQL function. | `.create function MyFunc() { Logs \| count }` |

#### 2\. Data Ingestion and Modification

These commands are used to load data into tables or alter existing data.

| Command | Purpose | Example |
| :--- | :--- | :--- |
| **`.ingest into`** | Ingests data from a specified source (like an external file/blob) into a table. | `.ingest into table Logs ('<BlobUri>')` |
| **`.set-or-append`** | Ingests the result of a query into an existing table or creates it if it doesn't exist. | `.set-or-append MyTable <\| MyQuery \| summarize count()` |
| **`.delete`** | Deletes records from a table based on a predicate (requires the `EnableDelete` policy). | `.delete from table Logs where Timestamp < ago(365d)` |
| **`.set`** | Creates a new table and sets its contents to the result of a query. | `.set NewTable <\| Logs \| take 100` |

#### 3\. Show/Display Commands

These commands are read-only and are used to view the cluster's current state, metadata, and history.

| Command | Purpose | Example |
| :--- | :--- | :--- |
| **`.show tables`** | Returns a list of all tables in the current database. | `.show tables` |
| **`.show database schema`** | Returns the entire schema of the database. | `.show database schema` |
| **`.show commands`** | Returns a list of management commands that have recently run on the cluster. | `.show commands \| where StartedOn > ago(1h)` |
| **`.show functions`** | Returns a list of all stored functions. | `.show functions` |

#### 4\. Policy Management

These commands manage various policies on databases, tables, or columns (e.g., retention, caching, sharding).

| Command | Purpose | Example |
| :--- | :--- | :--- |
| **`.alter table policy retention`**| Sets the data retention period for a table. | `.alter table Logs policy retention softdelete = 365d` |
| **`.alter-merge workload_group`** | Modifies the settings for a workload group, such as request limits. | `.alter-merge workload_group default ...` |

-----

### Combining Queries and Control Commands

It's possible to pass the result of a KQL query into a Control Command, typically for data ingestion or modification operations. This is done using the **`<\!`** operator, as seen in the `.set` or `.set-or-append` examples above.

Conversely, some "show" commands can be piped **(`\|`)** into a KQL query to perform further analysis on the returned metadata:

```kql
// The .show tables command returns a table, which is then piped into the KQL 'count' operator.
.show tables 
| count
```

You can learn more about Azure Data Explorer management commands by watching [Database Management Commands For Azure Data Explorer by using Kusto Query](https://www.youtube.com/watch?v=jB0MSQQywHs).
http://googleusercontent.com/youtube_content/0

Kusto Query Language (**KQL**) supports two main types of functions: **Built-in Functions** and **User-Defined Functions**.

### **1. Built-in Functions**

These are hard-coded functions defined by Kusto that cannot be modified by users. They are categorized based on their behavior, primarily as:

| Function Type | Description | Common Examples |
| :--- | :--- | :--- |
| **Scalar Functions** | Operate on single values to perform basic operations and return a single value. Used for data manipulation. | `tolower()`, `strlen()`, `round()`, `now()`, `datetime_add()`, `substring()`, `strcat()` |
| **Aggregation Functions** | Perform calculations over multiple rows of data (usually with the `summarize` operator) and return a single summary value for each group. | `count()`, `sum()`, `avg()`, `min()`, `max()`, `dcount()`, `make_list()` |
| **Window Functions** | Perform a calculation across a set of table rows that are related to the current row, returning a result for *each* row. Used for time-series and sequential analysis. | `row_number()`, `prev()`, `next()`, aggregate functions used with an `over` clause (though Kusto's `row_number()` is typically used with the `serialize` operator). |

-----

### **2. User-Defined Functions (UDFs)**

These are reusable queries or query parts that you define yourself. They help modularize code and reduce redundancy. UDFs are divided into two types:

  * **Query-Defined Functions:**

      * Defined and used within the scope of a single query using the **`let` statement**.
      * They are local to the query.

    ***Example:***

    ```kql
    let AddTwo = (value:long) { value + 2 };
    range x from 1 to 3 step 1 | extend Result = AddTwo(x)
    ```

  * **Stored Functions:**

      * User-defined functions that are **stored** as database schema entities (similar to tables) and are available across multiple queries and users.
      * They are created using the **`.create function`** command.

Both query-defined and stored UDFs can be defined as either:

  * **Scalar Functions:** Returns a single scalar value.
  * **Tabular Functions:** Returns a tabular expression (a table).

This video provides a deep dive into using KQL functions, including scalar and tabular examples.
[KQL Tutorial Series - You need to learn KQL Functions\! (Labs included) | EP7](https://www.youtube.com/watch?v=ZlZvGmLkgPU)
http://googleusercontent.com/youtube_content/1

