**Kusto Query Language (KQL)** is a powerful, read-only language developed by Microsoft for querying structured, semi-structured, and unstructured data. In Azure, it is most commonly used in **Azure Monitor Logs** (Log Analytics), **Azure Data Explorer**, and **Microsoft Sentinel** for analyzing logs, metrics, and telemetry data.

KQL is designed to be easy to read and write, using a data-flow model where data is passed from one command (operator) to the next using the **pipe character** (`|`). The query generally starts with a table name and then applies filters, aggregations, and projections sequentially.

-----

## Key KQL Operators

| Operator | Purpose | SQL Equivalent |
| :--- | :--- | :--- |
| `tablename` | The starting point of the query, specifying the data source. | `FROM tablename` |
| `where` | Filters the table's rows based on a specific condition. | `WHERE` |
| `project` | Selects specific columns to include in the output. | `SELECT` |
| `summarize` | Groups data and calculates aggregations (e.g., count, sum, average). | `GROUP BY` and aggregate functions |
| `extend` | Creates a new calculated column. | N/A (similar to a calculated column in `SELECT`) |
| `order by` | Sorts the result set by one or more columns. | `ORDER BY` |
| `take` | Limits the number of rows returned. | `TOP` or `LIMIT` |

-----

## KQL Queries for Common Scenarios

Here are a few example queries using KQL to understand common Azure monitoring scenarios. These are typically run in the **Log Analytics** workspace in Azure Monitor.

### 1\. Simple Data Retrieval and Filtering

**Scenario:** Get the last 10 records from the `SecurityEvent` table that represent a successful login (EventID 4624) in the last hour.

```kql
SecurityEvent
| where TimeGenerated > ago(1h)
| where EventID == 4624
| take 10
| project TimeGenerated, Computer, Account
```

  * `SecurityEvent`: Specifies the table to query.
  * `where TimeGenerated > ago(1h)`: Filters records to only those created in the last 1 hour.
  * `where EventID == 4624`: Filters to a specific Windows Event ID for successful logons.
  * `take 10`: Limits the output to 10 records.
  * `project ...`: Selects and displays only the `TimeGenerated`, `Computer`, and `Account` columns.

### 2\. Aggregation and Time-Series Analysis

**Scenario:** Count the total number of errors (`Level == 2`) per computer over the last 7 days, grouped by day.

```kql
Heartbeat
| where TimeGenerated > ago(7d)
| summarize DailyErrorCount = countif(Computer == "Error") by bin(TimeGenerated, 1d)
| render timechart 
```

  * `Heartbeat`: Specifies the table (often used for agent status).
  * `summarize ... by bin(TimeGenerated, 1d)`: Groups the records by a 1-day interval (`bin`) and calculates a count of records where the `Computer` column equals "Error" (using `countif`).
  * `render timechart`: Displays the results as a line chart over time. (Note: The `Heartbeat` table doesn't have an error level, but this demonstrates the syntax for summarizing by time).

### 3\. Calculating Percentiles and Sorting

**Scenario:** Find the 95th percentile and average duration of application requests in the last 24 hours, grouped by the request name.

```kql
AppRequests
| where TimeGenerated > ago(24h)
| summarize 
    AvgDuration = avg(DurationMs), 
    P95Duration = percentile(DurationMs, 95), 
    TotalRequests = count()
  by OperationName
| order by P95Duration desc
```

  * `AppRequests`: Specifies the table for application request data.
  * `summarize ... by OperationName`: Groups the results by the request name and calculates the average duration, the 95th percentile duration, and the total count of requests.
  * `order by P95Duration desc`: Sorts the final result table to show the slowest requests first.

This video provides an excellent introduction to the basics and fundamental building blocks of the KQL language, which is essential for working with log data in Azure. [Kusto Query Language Tutorial | Basics | Beginner To Pro in 30 Minutes](https://www.google.com/search?q=https://www.youtube.com/watch%3Fv%3DImqRQJfnSH4)


<img width="942" height="527" alt="image" src="https://github.com/user-attachments/assets/8479a7ea-769d-4f57-98a3-70ced304bc66" />


The **Kusto Query Language (KQL)** supports several **scalar data types**, which are single values that hold specific kinds of data. These are the fundamental types used for columns in KQL tables, variables defined with `let` statements, and values returned by functions.

The core scalar data types in KQL are:

| Type Name | Alternative Name(s) | Description | Example Literal |
| :--- | :--- | :--- | :--- |
| **`string`** | | A sequence of zero or more Unicode characters (text). | `"Hello, KQL"` |
| **`long`** | `int` | A signed 64-bit integer (whole number). `int` is also supported but resolves to a 32-bit signed integer. | `123456` |
| **`real`** | `double` | A 64-bit double-precision floating-point number (decimal numbers). | `1.23` or `1.0` |
| **`decimal`** | | A 128-bit wide decimal number, used for high-precision calculations like currency. | `decimal(10.99)` |
| **`bool`** | `boolean` | A logical value that is either **`true`** (`1`) or **`false`** (`0`). | `true` or `false` |
| **`datetime`** | `date` | An instant in time, typically expressed as a date and time of day (up to the millisecond). | `datetime(2025-10-04 10:00:00)` |
| **`timespan`** | `time` | A time interval, representing a duration of time (e.g., 5 days, 1 hour). | `5d` or `1h` or `timespan(0.01:00:00)` |
| **`guid`** | `uuid`, `uniqueid` | A 128-bit globally unique value (UUID). | `guid("12345678-abcd-1234-abcd-1234567890ab")` |
| **`dynamic`** | | A container that can hold any of the other scalar data types, or a structured value like an **array** or a **property bag** (dictionary/JSON object). | `dynamic({"key": "value", "count": 10})` |

***

### Important Type Considerations

* **Case Sensitivity:** KQL is generally case-sensitive for everything, including table and column names, so ensure you use the correct casing for values, especially with strings.
* **Null Values:** All non-`string` data types include a special **`null`** value, representing the lack of data or a data mismatch. The `isnull()` function is used to check for this value.
* **`dynamic` Type:** This is particularly important when dealing with unstructured data like JSON logs in Azure Monitor. It allows you to ingest and query semi-structured data, and KQL provides specific operators (like `parse_json()`, `mv-expand`, and dynamic object accessors) to manipulate it.
* 


**Kusto Control Commands** (also known as **Management Commands**) are requests to the Kusto service to **process or modify data or metadata**. Unlike Kusto Query Language (KQL) queries, which are read-only requests to process data and return results, control commands are used for administration, data ingestion, scheme modifications, and policy management.

### Key Differentiator

The fundamental distinction between a KQL query and a Control Command is its syntax:

  * **Control Commands** **must** start with the **dot (`.`)** character (e.g., `.show tables`).
  * **KQL Queries** **must not** start with the dot (`.`) character (e.g., `StormEvents | count`).

This design is a security measure to prevent embedding commands (which modify state) within read-only queries.

-----

### Common Categories of Control Commands

Control commands cover a wide range of administrative and data management tasks. They can be broadly categorized as:

#### 1\. Schema and Metadata Management

These commands are used to create, alter, or drop databases, tables, columns, and functions.

| Command | Purpose | Example |
| :--- | :--- | :--- |
| **`.create table`** | Creates a new table with a specified schema. | `.create table Logs (Timestamp: datetime, Message: string)` |
| **`.alter table`** | Modifies an existing table's schema (e.g., adding a column). | `.alter table Logs (Level: string)` |
| **`.drop table`** | Deletes a table. | `.drop table Logs` |
| **`.create function`** | Creates a stored KQL function. | `.create function MyFunc() { Logs \| count }` |

#### 2\. Data Ingestion and Modification

These commands are used to load data into tables or alter existing data.

| Command | Purpose | Example |
| :--- | :--- | :--- |
| **`.ingest into`** | Ingests data from a specified source (like an external file/blob) into a table. | `.ingest into table Logs ('<BlobUri>')` |
| **`.set-or-append`** | Ingests the result of a query into an existing table or creates it if it doesn't exist. | `.set-or-append MyTable <\| MyQuery \| summarize count()` |
| **`.delete`** | Deletes records from a table based on a predicate (requires the `EnableDelete` policy). | `.delete from table Logs where Timestamp < ago(365d)` |
| **`.set`** | Creates a new table and sets its contents to the result of a query. | `.set NewTable <\| Logs \| take 100` |

#### 3\. Show/Display Commands

These commands are read-only and are used to view the cluster's current state, metadata, and history.

| Command | Purpose | Example |
| :--- | :--- | :--- |
| **`.show tables`** | Returns a list of all tables in the current database. | `.show tables` |
| **`.show database schema`** | Returns the entire schema of the database. | `.show database schema` |
| **`.show commands`** | Returns a list of management commands that have recently run on the cluster. | `.show commands \| where StartedOn > ago(1h)` |
| **`.show functions`** | Returns a list of all stored functions. | `.show functions` |

#### 4\. Policy Management

These commands manage various policies on databases, tables, or columns (e.g., retention, caching, sharding).

| Command | Purpose | Example |
| :--- | :--- | :--- |
| **`.alter table policy retention`**| Sets the data retention period for a table. | `.alter table Logs policy retention softdelete = 365d` |
| **`.alter-merge workload_group`** | Modifies the settings for a workload group, such as request limits. | `.alter-merge workload_group default ...` |

-----

### Combining Queries and Control Commands

It's possible to pass the result of a KQL query into a Control Command, typically for data ingestion or modification operations. This is done using the **`<\!`** operator, as seen in the `.set` or `.set-or-append` examples above.

Conversely, some "show" commands can be piped **(`\|`)** into a KQL query to perform further analysis on the returned metadata:

```kql
// The .show tables command returns a table, which is then piped into the KQL 'count' operator.
.show tables 
| count
```

You can learn more about Azure Data Explorer management commands by watching [Database Management Commands For Azure Data Explorer by using Kusto Query](https://www.youtube.com/watch?v=jB0MSQQywHs).
http://googleusercontent.com/youtube_content/0

Kusto Query Language (**KQL**) supports two main types of functions: **Built-in Functions** and **User-Defined Functions**.

### **1. Built-in Functions**

These are hard-coded functions defined by Kusto that cannot be modified by users. They are categorized based on their behavior, primarily as:

| Function Type | Description | Common Examples |
| :--- | :--- | :--- |
| **Scalar Functions** | Operate on single values to perform basic operations and return a single value. Used for data manipulation. | `tolower()`, `strlen()`, `round()`, `now()`, `datetime_add()`, `substring()`, `strcat()` |
| **Aggregation Functions** | Perform calculations over multiple rows of data (usually with the `summarize` operator) and return a single summary value for each group. | `count()`, `sum()`, `avg()`, `min()`, `max()`, `dcount()`, `make_list()` |
| **Window Functions** | Perform a calculation across a set of table rows that are related to the current row, returning a result for *each* row. Used for time-series and sequential analysis. | `row_number()`, `prev()`, `next()`, aggregate functions used with an `over` clause (though Kusto's `row_number()` is typically used with the `serialize` operator). |

-----

### **2. User-Defined Functions (UDFs)**

These are reusable queries or query parts that you define yourself. They help modularize code and reduce redundancy. UDFs are divided into two types:

  * **Query-Defined Functions:**

      * Defined and used within the scope of a single query using the **`let` statement**.
      * They are local to the query.

    ***Example:***

    ```kql
    let AddTwo = (value:long) { value + 2 };
    range x from 1 to 3 step 1 | extend Result = AddTwo(x)
    ```

  * **Stored Functions:**

      * User-defined functions that are **stored** as database schema entities (similar to tables) and are available across multiple queries and users.
      * They are created using the **`.create function`** command.

Both query-defined and stored UDFs can be defined as either:

  * **Scalar Functions:** Returns a single scalar value.
  * **Tabular Functions:** Returns a tabular expression (a table).

This video provides a deep dive into using KQL functions, including scalar and tabular examples.
[KQL Tutorial Series - You need to learn KQL Functions\! (Labs included) | EP7](https://www.youtube.com/watch?v=ZlZvGmLkgPU)
http://googleusercontent.com/youtube_content/1


**Kusto Query Language (KQL) scalar operators** are used to perform operations on single data values (scalars) to produce a new scalar value. These are distinct from **tabular operators** which operate on and produce tables.

Scalar operators are frequently used within the `where`, `extend`, `project`, and `summarize` tabular operators to perform calculations, comparisons, and manipulations.

## Categories of Scalar Operators

KQL supports a wide range of scalar operators, including:

***

### 1. Comparison Operators

Used to compare two scalar expressions, resulting in a boolean (`bool`) scalar value (true or false).

| Operator | Description | Example |
| :--- | :--- | :--- |
| `==` | Equals (case-sensitive) | `1 + 1 == 2` (returns true) |
| `!=` | Not equals (case-sensitive) | `'A' != 'a'` (returns true) |
| `=~` | Equals (case-insensitive) | `'Hello' =~ 'hello'` (returns true) |
| `!~` | Not equals (case-insensitive) | `'Hello' !~ 'world'` (returns true) |
| `<` | Less than | `5 < 10` |
| `>` | Greater than | `10 > 5` |
| `<=` | Less than or equal to | `5 <= 5` |
| `>=` | Greater than or equal to | `10 >= 5` |

***

### 2. Logical Operators

Used to combine or negate boolean expressions.

| Operator | Description | Example |
| :--- | :--- | :--- |
| `and` | Logical AND | `A > 10 and B < 20` |
| `or` | Logical OR | `C == 5 or D == 10` |
| `not` | Logical NOT | `not(A == 0)` |

***

### 3. Arithmetic Operators

Used for mathematical calculations on numeric, datetime, and timespan values.

| Operator | Description | Example |
| :--- | :--- | :--- |
| `+` | Addition (Numeric, Datetime/Timespan) | `5 + 3`, `now() + 1d` |
| `-` | Subtraction (Numeric, Datetime/Timespan) | `10 - 4`, `now() - 1h` |
| `*` | Multiplication (Numeric) | `2 * 6` |
| `/` | Division (Numeric) | `10 / 2` |
| `%` | Modulo (Remainder) | `10 % 3` |

***

### 4. String Operators

Used for checking if a string contains, starts with, or ends with another string, often used in `where` clauses for filtering. Many of these have case-sensitive (`_cs`) and case-insensitive versions.

| Operator | Description | Example |
| :--- | :--- | :--- |
| `contains` | Checks for a substring (case-insensitive) | `State contains 'fornia'` |
| `!contains` | Checks for the absence of a substring (case-insensitive) | `State !contains 'Ohio'` |
| `has` | Checks for a full term/word (better performance than `contains`) | `Message has 'error'` |
| `startswith` | Checks if the string begins with a prefix (case-insensitive) | `Computer startswith 'Web'` |
| `endswith` | Checks if the string ends with a suffix (case-insensitive) | `File endswith '.log'` |
| `in` | Checks if a value is present in a comma-separated list or dynamic array | `State in ('FLORIDA', 'TEXAS')` |

***

### 5. Other Key Scalar Functions (often treated conceptually as operators)

While technically functions, these are essential for scalar manipulation:

* **`iif(condition, if_true, if_false)`**: A conditional function similar to an if/else statement.
* **`case()`**: A conditional function for multiple conditions.
* **`ago(timespan)`**: Returns a datetime value that is a certain timespan before the current time (`now()`). E.g., `ago(1d)` is 24 hours ago.
* **`bin(value, roundTo)`**: Rounds down a value (numeric or datetime) to a specified bin size.

This video provides an introductory overview of KQL, which includes concepts like scalar functions and operators.
[KQL Tutorial Series - You need to learn KQL Functions! (Labs included) | EP7](https://www.youtube.com/watch?v=ZlZvGmLkgPU)
http://googleusercontent.com/youtube_content/2


**Kusto Tabular Operators** are essential components of the **Kusto Query Language (KQL)**, used to process tabular data (data in rows and columns).

A Kusto query primarily consists of one or more **tabular expression statements**. These statements take a tabular input and return a tabular output, modeling a data-flow pipeline.

### Key Characteristics

* **Data Flow:** Data moves from one operator to the next using the pipe character ($\text{|}$). The output of one operator serves as the input for the next. This sequential flow is critical, as the order of operators affects both results and performance.
* **Purpose:** At each step, an operator filters, rearranges, summarizes, or otherwise manipulates the tabular data.
* **Composition:** A tabular expression statement is generally composed of:
    1.  A tabular **data source** (like a table reference).
    2.  One or more tabular **data operators** (filters, projections, aggregations).
    3.  Optional **rendering operators** (for visualization).

### Common Examples of Tabular Operators

Some of the most frequently used Kusto tabular operators include:

| Operator | Function | Example Usage |
| :--- | :--- | :--- |
| **`where`** | Filters the table's records based on a predicate (condition). | `Table \| where ColumnA == "value"` |
| **`project`** | Selects, renames, and defines new columns to include in the output. | `Table \| project NewColumn = ColumnA, ColumnB` |
| **`summarize`** | Aggregates data by grouping rows, often used with functions like `count()`, `sum()`, or `avg()`. | `Table \| summarize count() by ColumnC` |
| **`sort`** or **`order`** | Sorts the rows of the input table by one or more columns. | `Table \| sort by ColumnD desc` |
| **`join`** | Merges the rows of two tabular inputs based on matching values of specified columns. | `TableA \| join (TableB) on CommonID` |
| **`union`** | Combines the rows from two or more tables or tabular expressions. | `TableA \| union TableB` |
| **`extend`** | Adds calculated columns to the input table. | `Table \| extend NewTime = now()` |
| **`top`** | Returns the first *N* records according to the specified columns for sorting. | `Table \| top 10 by Score asc` |

---
You can learn more about combining data in KQL using this video: [Understanding the KQL union Operator](https://www.youtube.com/watch?v=zG6nCKTDnug). This video is relevant as it dives deep into the functionality of the `union` tabular operator in KQL.
http://googleusercontent.com/youtube_content/0


That's a great way to understand them\! Here are a few examples of common Kusto Query Language (KQL) queries that showcase the most popular **tabular operators**.

Each query starts with a table name and uses the pipe ($\text{|}$) character to pass data from one operator to the next.

### 1\. Filtering and Counting (`where`, `count`)

This example shows how to **filter** rows based on a condition and then get the **total number** of resulting rows.

| Operator | Action |
| :--- | :--- |
| `where` | Filters the data. |
| `count` | Returns the total number of rows. |

```kusto
// Get the number of error logs from the last hour
Traces
| where SeverityLevel == 3  // Filter for 'Error' severity (assuming 3 means error)
| where timestamp > ago(1h) // Filter for records in the last 1 hour
| count
```

-----

### 2\. Aggregation and Grouping (`summarize`)

This query demonstrates how to **group** data by a column and then **calculate an aggregate** (like a count or sum) for each group.

| Operator | Action |
| :--- | :--- |
| `summarize` | Calculates aggregations over groups of rows. |

```kusto
// Count the number of events per state in the StormEvents table
StormEvents
| where StartTime >= ago(7d) 
| summarize EventCount = count() by State // Group by 'State' and count the records in each group
| sort by EventCount desc
```

-----

### 3\. Column Manipulation (`project`, `extend`)

These operators are used to select, rename, or create new columns.

| Operator | Action |
| :--- | :--- |
| `project` | Selects a subset of columns to display. |
| `extend` | Adds a new calculated column to the table. |

```kusto
// Select and rename columns, and calculate a new value
Requests
| extend ResponseTimeSec = todouble(DurationMs) / 1000.0 // Add a new column to convert duration to seconds
| where ResponseTimeSec > 5.0
| project 
    RequestName,
    Duration = ResponseTimeSec, // Rename the calculated column for output
    UserAgent
```

-----

### 4\. Combining Data (`join`)

The `join` operator merges two tables side-by-side based on matching values in a key column.

| Operator | Action |
| :--- | :--- |
| `join` | Merges two tables. |

```kusto
// Get User details for specific errors
Errors
| where ErrorCode == 500
| join kind=inner ( // Join with the Users table
    Users
    | project UserId, UserName, UserEmail
) on UserId // The column to match on in both tables
| project timestamp, UserName, UserEmail, ErrorDetails
```

